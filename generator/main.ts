import { Spec } from "swagger-schema-official";
import { pathPreferences, IPathPreference } from "../src/preference";
let swaggerSpec: Spec = require("./swagger-api.json");
import { uniq, groupBy, toPairs, difference } from "lodash";

import * as fs from "fs";
import * as path from "path";
import * as prettier from "prettier";
import { generateApiFunctions } from "./ajax-code";
import { getPathChunks, grabPathname, byPublicApi, byInternalApi, FuncTagFilter } from "./util/string";
import { getCodeOfAllInterfaces, clearInterfacesList } from "./interface-collector";

// 检查代码是否正常

let checkPaths = (apiPaths: string[], definedPaths: string[]) => {
  definedPaths.forEach((p) => {
    if (p.includes("/:")) {
      console.warn("Suspicious path with colon in variables:", p);
    }
  });
  let deltaPaths = difference(apiPaths, definedPaths);
  if (deltaPaths.length > 0) {
    console.warn("[WARN] Paths in preference not used:", deltaPaths);
  }
  deltaPaths = difference(definedPaths, apiPaths);
  if (deltaPaths.length > 0) {
    console.warn("[WARN] New paths not configured:", deltaPaths);
  }
};

checkPaths(Object.keys(pathPreferences), Object.keys(swaggerSpec.paths));

// 基于路径分离出 chunks

let definedPaths = Object.keys(swaggerSpec.paths).slice().sort();

interface IPathInfo {
  original: string;
  chunks: string[];
}

let activePaths: IPathInfo[] = definedPaths
  .filter((urlPath) => {
    let ignored = pathPreferences[urlPath]?.ignored;
    return ignored == null || ignored === false;
  })
  .map((urlPath) => {
    return {
      original: urlPath,
      chunks: getPathChunks(urlPath),
    };
  });

// 基于 chunks 创建属性结构

let buildTree = (rules: IPathInfo[]): IPathNode[] => {
  rules.forEach((rule) => {
    if (rule.chunks.length === 0) {
      console.error("Invalid rule with chunk length 0:", rule);
    }
  });

  let groupedRules = groupBy(rules, (rule) => rule.chunks[0]);

  return toPairs(groupedRules).map(([chunk, children]) => {
    let loweredChildren = children.map((child) => {
      return { ...child, chunks: child.chunks.slice(1) };
    });

    let theRule = loweredChildren.find((x) => x.chunks.length === 0);
    let childRules = loweredChildren.filter((x) => x.chunks.length > 0);
    return {
      chunk,
      original: theRule?.original || null,
      children: childRules.length > 0 ? buildTree(childRules) : undefined,
    };
  });
};

interface IPathNode {
  chunk: string;
  original: string;
  children: IPathNode[];
}

let apiTree: IPathNode[] = buildTree(
  activePaths.filter((pathNode) => {
    let pathObject = swaggerSpec.paths[pathNode.original];
    return byPublicApi(pathObject.get?.tags) || byPublicApi(pathObject.post?.tags) || byPublicApi(pathObject.put?.tags) || byPublicApi(pathObject.delete?.tags);
  })
);
let internalApiTree: IPathNode[] = buildTree(
  activePaths.filter((pathNode) => {
    let pathObject = swaggerSpec.paths[pathNode.original];
    return (
      byInternalApi(pathObject.get?.tags) ||
      byInternalApi(pathObject.post?.tags) ||
      byInternalApi(pathObject.put?.tags) ||
      byInternalApi(pathObject.delete?.tags)
    );
  })
);

// 开始生成代码

let generateCodeOfChildren = (pathNodes: IPathNode[], tagFilter: FuncTagFilter) => {
  if (pathNodes == null || pathNodes.length === 0) {
    return "";
  }
  return pathNodes
    .map((node) => {
      let apiCode = "";
      let preference = pathPreferences[node.original];
      if (node.original != null) {
        apiCode = generateApiFunctions(node.original, swaggerSpec.paths[node.original], tagFilter);
      }

      return `
    ${node.chunk}: {
      ${apiCode}
      ${generateCodeOfChildren(node.children, tagFilter)}
    },
    `.trim();
    })
    .join("\n");
};

let generateApiTreeCode = (name: string, pathNodes: IPathNode[], tagFilter: FuncTagFilter) => {
  clearInterfacesList();
  let body = generateCodeOfChildren(pathNodes, tagFilter);
  return `
  export let ${name} = {
    ${body}
  }

  ${getCodeOfAllInterfaces()}

  `.trim();
};

let generatedCode = generateApiTreeCode("genSeedApiTree", apiTree, byPublicApi);

// Format with Prettier
let prettierConfigs = JSON.parse(fs.readFileSync(path.join(process.env.PWD, ".prettierrc"), "utf8"));
prettierConfigs.parser = "typescript";

try {
  generatedCode = prettier.format(generatedCode, prettierConfigs);
} catch (error) {
  console.log(error);
  console.log("格式化没有成功, 使用原始代码");
}

let lineSeparator = `\n/** Generated by generator */\n`;
let publicFile = "src/generated-api-tree.ts";

// Read write file

let writeFile = (fileName: string, code: string) => {
  let previousCode = fs.readFileSync(fileName, "utf8");
  let staticPart = previousCode.split(lineSeparator)[0];
  fs.writeFileSync(fileName, `${staticPart}${lineSeparator}\n${code}`);
  console.log(`Wrote code to ${fileName}`);
};

writeFile(publicFile, generatedCode);
